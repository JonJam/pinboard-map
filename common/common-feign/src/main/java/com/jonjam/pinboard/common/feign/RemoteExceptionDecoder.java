package com.jonjam.pinboard.common.feign;

import javax.inject.Inject;
import javax.ws.rs.WebApplicationException;
import java.io.IOException;
import java.io.Reader;
import java.io.StringWriter;
import java.util.Collection;
import java.util.Collections;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jonjam.pinboard.common.exception.RemoteExceptionDto;
import com.jonjam.pinboard.common.logging.StructuredLogger;
import feign.FeignException;
import feign.Response;
import feign.codec.ErrorDecoder;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;

public class RemoteExceptionDecoder implements ErrorDecoder {

    private static final StructuredLogger LOG = StructuredLogger.getLogger(RemoteExceptionDecoder.class);
    private static final String JSON_CONTENT_TYPE = "application/json";

    private final ObjectMapper objectMapper;

    @Inject
    public RemoteExceptionDecoder(final ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public Exception decode(
        final String methodKey,
        final Response response) {

        String responseBody;

        try {
            responseBody = readResponseBody(response);
        } catch (final IOException ex) {
            return ex;
        }

        try {
            final RemoteExceptionDto remoteException = getRemoteExceptionDtoFromResponse(responseBody, response);

            if (remoteException != null) {
                final JsonNode exceptionDetails = remoteException.getExceptionDetails();

                if (remoteException.getExceptionType() == null) {
                    LOG.info()
                       .withData("type", remoteException.getExceptionType())
                       .withData("status", response.status())
                       .write("Exception type null.");

                    return new WebApplicationException(responseBody, response.status());
                } else {
                    try {
                        final Class<? extends Exception> exceptionType = Class.forName(remoteException.getExceptionType())
                                                                              .asSubclass(Exception.class);
                        return objectMapper.treeToValue(exceptionDetails, exceptionType);
                    } catch (final ClassNotFoundException cnfe) {
                        LOG.info()
                           .withData("type", remoteException.getExceptionType())
                           .withData("status", response.status())
                           .write("Exception type not found.");

                        final String exceptionDetailsJSON = objectMapper.writer()
                                                                        .writeValueAsString(exceptionDetails);

                        return new WebApplicationException(exceptionDetailsJSON, response.status());
                    }
                }

            }

        } catch (final IOException ex) {
            LOG.warn()
               .write("Caught Exception trying to interpret error response from server", ex);
        }

        LOG.warn()
           .withData("status", response.status())
           .withData("reason", response.reason())
           .withData("body", responseBody)
           .write("Error response could not be interpreted");

        return FeignException.errorStatus(methodKey, response);
    }

    protected RemoteExceptionDto getRemoteExceptionDtoFromResponse(
        final String responseBody,
        final Response response) throws IOException {

        final Collection<String> contentTypeHeaders = response.headers()
                                                              .getOrDefault("Content-Type", Collections.emptyList());
        final String contentType = contentTypeHeaders.isEmpty() ? null : contentTypeHeaders.iterator().next();

        if ((contentType != null)
            && (responseBody != null)
            && (StringUtils.substringBefore(contentType, ";").equals(JSON_CONTENT_TYPE))) {
            return objectMapper.readValue(responseBody, RemoteExceptionDto.class);
        }

        return null;
    }

    protected String readResponseBody(final Response response) throws IOException {
        try (final StringWriter writer = new StringWriter()) {
            final Response.Body body = response.body();

            if (body == null) {
                // Well general HTTP error, w/o body which could not represent anything interesting but:
                // HTTP errors generated by load balancers, proxies or mod_sec rules
                return null;
            }

            try (final Reader reader = body.asReader()) {
                IOUtils.copy(reader, writer);
            } catch (final IOException ex) {
                LOG.warn()
                   .withData("body", writer.toString())
                   .write("Caught IOException reading response", ex);

                throw ex;
            }

            return writer.toString();
        }
    }
}

